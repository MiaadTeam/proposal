 با توجه به اینکه graphql یک مشخصه و زبان توصیف مدل داده ها و نحوه درخواست
    آنها است، علاوه بر پیاده سازی معمول برنامه سرور نیاز به پیاده سازی مختص به
    graphql نیز می باشد که این مورد، یکی از اصل های اساسی برنامه نویسی که "عدم
    تکرار" است را نقض می نماید و توسعه دهندگان را مجبور به یادگیری زبان توصیفی
    منحصر به graphql یعنی gql می کند.

1.  پس از اینکه توصیف مدل داده ها را به زبان graphql انجام میشود، به ازای ارسال
    هر درخواست به سمت سرور نیاز به تجزیه و تحلیل متون توصیفی است که این فرآیند
    نیز، دارای سربار پردازشی میباشد.

![](media/63530c46f07e63f96f2b36529d7e79e5.png)

1.  یکی از موارد که در graphql مدیریت میشد، ارسال داده ها به همراه روابطشان است
    اما مشکل مهمی که در این قسمت به وجود می آید، عدم کنترل عمق و نوع روابطی است
    که کلاینت می تواند درخواست نماید. این عامل سبب تولید درخواست های غیر بهینه
    توسط کلاینت میشود.

![](media/ac2845b6616f533c4903853b7af82d30.png)

1.  در graphql برای درخواست یک داده باید نام آن به طور کامل ذکر شود بنابراین در
    حالتی که نیاز به همه یا اکثریت داده های یک موجودیت داریم باید تمامی اسامی
    داده ها ذکر شود که همین موجب اشغال پهنای باند شبکه و کاهش سرعت ارسال درخواست
    به سرور میشود.

2.  graphql یک زبان توصیفی با رویکرد کلی است و برای پایگاه داده خاصی بهینه نشده
    است. در واقع این ابزار هیچ دیدی نسبت به اینکه در ساختارهای دیگر چه پیاده
    سازی انجام شده است، ندارد و قاعدتا بهینه سازی خاصی نیز روی آن اتفاق نیفتاده
    است.

3.  ارسال درخواست در graphql در قالب فرمت های متداول رایج مانند json نبوده و
    همین عامل سبب میشود تا ارسال درخواست با بسیاری از ابزار های فعلی، امری
    پیچیده تلقی شود.

جهت حل مشکلات بالا ما funql را با توجه به امکانات و ابزار های موجود در زبان
توسعه طراحی نمودیم.

عدم نیاز به تعریف مجدد موجودیت ها یا توابع در funql باعث میشود که توسعه برنامه
سرور سریع تر انجام پذیرد و منابع کمتری نیز صرف شود همچنین این کار باعث یکپارچگی
بیشتر در برنامه سرور میشود به عنوان مثال مغایرت نوع داده های تعریف شده در مشخصه
های graphql با نوع داده های تعریف شده در زبان توسعه، موجب عدم یکپارچگی برنامه
سرور می‌شود. بعلاوه این کار باعث میشود توسعه دهنده برنامه سرور نیازی به یادگیری
مجدد مواردی که قبلا و به شکل دیگر فراگرفته است، نداشته باشد.

افزودن منطق جدید دریافت اطلاعات، انعطاف بیشتر در گزینش اطلاعات دریافتی را به
ارمغان می آورد. این کار سبب میشود تا کلاینت بتواند بر اساس دو منطق 0 و 1 مشخص
نماید چه داده هایی را نیاز دارد و یا ندارد. اضافه شدن منطق 0 سبب کاهش اسراف
پهنای باند در درخواست همه یا اکثریت داده های یک موجودیت میشود. همچنین بر خلاف
graphql فرمت ارسال داده ها بر اساس استاندارد های موجود یعنی json طراحی شده است.

ارائه راهکاری جهت محدود کردن عمق و داده هایی که کلاینت می تواند درخواست کند نیز،
سبب حل شدن مشکل درخواست های غیر بهینه از سمت کلاینت می شود. این کار هماهنگی
کاملی بین منطق درخواست داده ها و نحوه مدل و ذخیره سازی داده ها در پایگاه داده را
به ارمغان می آورد.

Graphql برای جلوگیری از over-fetching و under-fetching روش Rest ایجاد شد اما در
کنار مزیت یاد شده دو ایراد مهم در آن وجود دارد:

۱. برای توصیف درخواست front-end از back-end از زبانی استفاده می شود که متداول

نیست و فهم آن هم برای ماشین و هم برای انسان مشکل ساز است

به عبارت دیگر علاوه بر زمانی که توسط انسان برای یادگیری مفاهیم آن صرف می شود،
برای ماشین هم سربار پردازشی اضافه ای ایجاد می کند که بخشی از منابع سرور را هدر
می دهد و ضرورتی ندارد

۲. در gql ما با یک رشته کار می کنیم که تمامی متغیر های درخواست را در خود جای
داده است و type safety را از بین برده است که در نتیجه آن امکان validation first
را نداریم

type safety به معنی آن است که مقداری که به یک متغیر تخصیص داده می شود از همان
نوعی باشد که برنامه نویس تعریف کرده است و انتظار دارد

هم چنین validation first به مفهوم این است که اولین کاری که در هنگام دریافت
درخواست انجام می شود بررسی مطابقت نوع متغیرهای دریافتی با نوع های تعریف شده است

در راه حل ما از فرمت json استفاده می شود که علاوه بر شناخته شده بودن برای انسان
و ماشین ،درهنگام ارسال درخواست قابلیت validation first با استفاده از کتابخانه
های موجود مانند fastest validator را فراهم می کند.

بسیاری از نفوذها و تهدیدات امنیتی در اثر ارسال داده های مخرب به سرور ایجاد می
شود و با این روش ، امکان بروز تعداد قابل توجهی از تهدیدات یادشده وجود نخواهد
داشت

از طرف دیگر امکان بروز خطا در هنگام اجرای برنامه کاهش چشمگیری خواهد داشت. اهمیت
این موضوع زمانی آشکار می شود که بدانیم گروهی از پژوهشگران دانشگاه MIT زبان Elm
را برای همین منظور توسعه داده اند. پس از صحت سنجی نوع داده ها ، بر اساس درخواست
کاربر تابع مورد نظر فراخوانی می شود

از آن جا که این توابع به روش functional programming پیاده سازی می شونددارای سه
ویژگی هستند :

-   reference : immutable داده ها تغییر داده نمی شود و پایدار هستند

-   pure function : به ازای ورودی مشخص خروجی مشخص داریم

-   no side effect : تابع از خارج خودش تاثیر پذیر نیست چرا که مقدار هیچ متغیری
    در خارج از تابع تعیین نمی شود.

بر این اساس، توابع ما قابلیت مهم تست نویسی را دارا هستند که از ارکان دنیای امروز
برنامه نویسی به شمار می رود و در دراز مدت، زمان توسعه و رفع خطا را به حداقل می
رساند.

این موضوع علاوه بر آن که در مرحله حاضر TDD یا Test Driven Development را ممکن می
کند به ما امکان حرکت در جهت IDD یا Issue Driven Development را می دهد . به این
ترتیب که حل مسائل بزرگ آینده را با استفاده از راه حل های چند صد هزار مسئله کوچک
قبلی فراهم کنیم و کدنویسی هوشمند توسط ماشین را محقق کنیم.
